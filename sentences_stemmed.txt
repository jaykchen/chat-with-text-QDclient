"", "\"#[derive(Debug)]\"", "\nAn attribute used to automatically derive the Debug trait for the enum Cereal.\n\n", "\"enum Cereal\"", "\nDefines an enum type called Cereal with various variants.\n\n", "\"Barley, Millet, Rice, Rye, Spelt, Wheat\"", "\nThe variants of the Cereal enum.\n\n", "\"fn main() {\"", "\nThe main function, which serves as the entry point of the program.\n\n", "\"let mut grains: Vec<Cereal> = vec![]\"", "\nDeclares a mutable variable named grains, which is a vector (dynamic array) of Cereal enum values. It is initially assigned an empty vector.\n\n", "\"grains.push(Cereal::Rye);\"", "\nAdds the Rye variant of the Cereal enum to the grains vector.\n\n", "\"drop(grains);\"", "\nInvokes the drop function on the grains vector, which releases its ownership and deallocates its resources.\n\n", "\"println!(\"{:?}\", grains);\"", "\nAttempts to print the contents of the grains vector, triggering a compilation error because grains has been moved (its ownership has been transferred) to the drop function, making it inaccessible for further use.", "", "\nThe inability to determine how a program behaves from run to run due to changing external factors. You’ll find this code in the ch1/ch1-race/src/ main.rs file.\n", "\nListing 1.4 Example of Rust preventing a race condition\n```\n1 use std::thread;\n2 fn main() {\n3     let mut data = 100;\n4\n5     thread::spawn(|| { data = 500; });\n6     thread::spawn(|| { data = 1000; });\n7     println!(\"{}\", data);\n8}\n```\n", "\nIf you are unfamiliar with the term thread, the upshot is that this code is not determin- istic. It’s impossible to know what value data will hold when main() exits. On lines 6 and 7 of the listing, two threads are created by calls to thread::spawn(). Each call takes a closure as an argument, denoted by vertical bars and curly braces (e.g., || {...}). The thread spawned on line 5 is attempting to set the data variable to 500, whereas the thread spawned on line 6 is attempting to set it to 1,000. Because the scheduling of threads is determined by the OS rather than the program, it’s impossible to know if the thread defined first will be the one that runs first.\n", "\n\nAttempting to compile listing 1.5 results in a stampede of error messages. Rust does not allow multiple places in an application to have write access to data. The code attempts to allow this in three places: once within the main thread running main() and once in each child thread created by thread::spawn(). Here’s the compiler message:\n```\n$ cargo run\n   Compiling ch1-race v0.1.0 (rust-in-action/code/ch1/ch1-race)\nerror[E0373]: closure may outlive the current function, but it borrows `data`, which is owned by the current function\n --> src/main.rs:6:19\n  |\n6 |     thread::spawn(|| { data = 500; });\n| ^^ ", "- `data` is borrowed here \n|            |\n| may outlive borrowed value `data` |\nnote: function requires argument type to outlive `'static`\n --> src/main.rs:6:5\n  |\n6 |     thread::spawn(|| { data = 500; });\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: to force the closure to take ownership of `data`\n      (and any other referenced variables), use the `move` keyword\n  |\n  |  thread::spawn(move || { data = 500; });\n  |            ^^^^^^^\n    error: aborting due to 4 previous errors\n    \nSome errors have detailed explanations: E0373, E0499, E0502.\nFor more information about an error, try `rustc --explain E0373`.\nerror: could not compile `ch1-race`.\n", "\nListing 1.5 provides an example of a buffer overflow. A buffer overflow describes situa- tions where an attempt is made to access items in memory that do not exist or that are illegal. In our case, an attempt to access fruit[4] results in the program crashing, as the fruit variable only contains three fruit. The source code for this listing is in the file ch1/ch1-fruit/src/main.rs.\n", "\nListing 1.5 Example of invoking a panic via a buffer overflow\n```\n1 fn main() {\n2 let fruit = vec![' ', ' ', ' ']; 3\n4     let buffer_overflow = fruit[4];\n5     assert_eq!(buffer_overflow, '  ')\n6}\n```\n", "\nWhen listing 1.5 is compiled and executed, you’ll encounter this error message:\n```\n    $ cargo run\n   Compiling ch1-fruit v0.1.0 (/rust-in-action/code/ch1/ch1-fruit)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/ch1-fruit`\nthread 'main' panicked at 'index out of bounds:\n    the len is 3 but the index is 4', src/main.rs:3:25\nnote: run with `RUST_BACKTRACE=1` environment variable\n    to display a backtrace\n```\n", "\nThe next listing shows an example of iterator invalidation, where an issue is caused by something that’s iterated over after being altered midway through. The source code for this listing is in ch1/ch1-letters/src/main.rs.\n", "\nListing 1.6 Attempting to modify an iterator while iterating over it\n```\n1 fn main() {\n2     let mut letters = vec![\n3 \"a\", \"b\", \"c\"\n4 ];\n5\n6 for letter in letters {\n7 println!(\"{}\", letter);\n8 letters.push(letter.clone());\n9   }\n10}\n```\n", "\nListing 1.6 fails to compile because Rust does not allow the letters variable to be modified within the iteration block. Here’s the error message: \n```\n$ cargo run\n   Compiling ch1-letters v0.1.0 (/rust-in-action/code/ch1/ch1-letters)\nerror[E0382]: borrow of moved value: `letters`\n --> src/main.rs:8:7\n  |\n2 | let mut letters = vec![\n    ", "", "", "-- move occurs because `letters` has type\n                `std::vec::Vec<&str>`, which does not\n                implement the `Copy` trait\n    ...   \n6 | for letter in letters {\n  |      ", "", "-\n  |    |\n  | `letters` moved due to this implicit call\n  |       to `.into_iter()`\n  |  help: consider borrowing to avoid moving\n  |        into the for loop: `&letters`\n7 | println!(\"{}\", letter);\n8 | letters.push(letter.clone());\n  | ^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n    \nFor more information about this error, try `rustc --explain E0382`.\n    \nerror: could not compile `ch1-letters`.\nTo learn more, run the command again with --verbose.\n```\n", "\nWhile the language of the error message is filled with jargon (borrow, move, trait, and so on), Rust has protected the programmer from stepping into a trap that many others fall into. And fear not—that jargon will become easier to understand as you work through the first few chapters of this book.\n    \nKnowing that a language is safe provides programmers with a degree of liberty. Because they know their program won’t implode, they become much more willing to experiment. Within the Rust community, this liberty has spawned the expression fear- less concurrency.\n    \n1.6.2 Goal of Rust: Productivity\nWhen given a choice, Rust prefers the option that is easiest for the developer. Many of its more subtle features are productivity boosts. But programmer productivity is a diffi- cult concept to demonstrate through an example in a book. Let’s start with something that can snag beginners—using assignment (=) within an expression that should use\nan equality (==) test:\n```  \n1 fn main() {\n2 let a = 10;\n3\n4 if a = 10 {\n5 println!(\"a equals ten\");\n6  } \n7}  \n```\n", "\nIn Rust, the preceding code fails to compile. The Rust compiler generates the following message:\n```\nerror[E0308]: mismatched types\n --> src/main.rs:4:8\n  |\n4 | if a = 10 { \n  | ^^^^^^ \n  |     |\n  |        expected `bool`, found `()`\n  |        help: try comparing for equality: `a == 10`\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `playground`.\nTo learn more, run the command again with --verbose.\n```\n", "\nAt first, “mismatched types” might feel like a strange error message to encounter. Surely we can test variables for equality against integers.\n    \nAfter some thought, it becomes apparent why the if test receives the wrong type. The if is not receiving an integer. It’s receiving the result of an assignment. In Rust, this is the blank type: (). () is pronounced unit.\n    \nWhen there is no other meaningful return value, expressions return (). As the fol- lowing shows, adding a second equals sign on line 4 results in a working program that prints a equals ten:\n```\n1 fn main() {\n2 let a = 10;\n3\n4 if a == 10 {\n5 println!(\"a equals ten\");\n6} \n7}\n```\n", "\nRust has many ergonomic features. It offers generics, sophisticated data types, pattern matching, and closures.15 Those who have worked with other ahead-of-time compila- tion languages are likely to appreciate Rust’s build system and its comprehensive pack- age manager: cargo.\n    \nAt first glance, we see that cargo is a front end for rustc, the Rust compiler, but cargo provides several additional utilities including the following:\n* cargo new creates a skeleton Rust project in a new directory (cargo init uses the current directory).\n* cargo build downloads dependencies and compiles the code.\n* cargo run executes cargo build and then also runs the resulting executable\nfile.\n* cargo doc builds HTML documentation for every dependency in the current project.\n\n1.6.3 Goal of Rust: Control\nRust offers programmers fine-grained control over how data structures are laid out in memory and their access patterns. While Rust uses sensible defaults that align with its “zero cost abstractions” philosophy, those defaults do not suit all situations.\n    \nAt times, it is imperative to manage your application’s performance. It might mat- ter to you that data is stored in the stack rather than on the heap. Perhaps, it might make sense to add reference counting to create a shared reference to a value. Occasion- ally, it might be useful to create one’s own type of pointer for a particular access pat- tern. The design space is large and Rust provides the tools to allow you to implement your preferred solution.\n    \nNOTE If terms such as stack, heap, and reference counting are new, don’t put the book down! We’ll spend lots of time explaining these and how they work together throughout the rest of the book.\n    \nListing 1.7 prints the line a: 10,b:20,c:30,d:Mutex{data:40}. Each represen- tation is another way to store an integer. As we progress through the next few chap- ters, the trade-offs related to each level become apparent. For the moment, the important thing to remember is that the menu of types is comprehensive. You are wel- come to choose exactly what’s right for your specific use case.\nListing 1.7 also demonstrates multiple ways to create integers. Each form provides differing semantics and runtime characteristics. But programmers retain full control of the trade-offs that they want to make.\nListing 1.7 Multiple ways to create integer values\n```\n 1 use std::rc::Rc;\n 2 use std::sync::{Arc, Mutex};\n 3\n 4 fn main() {\n 5 let a = 10;\n 6     let b = Box::new(20);\n 7     let c = Rc::new(Box::new(30));\n 8     let d = Arc::new(Mutex::new(40));\n 9     println!(\"a: {:?}, b: {:?}, c: {:?}, d: {:?}\", a, b, c, d);\n10 }\n```\n", "\nTo understand why Rust is doing something the way it is, it can be helpful to refer back to these three principles:\n* The language’s first priority is safety.\n* Data within Rust is immutable by default.\n* Compile-time checks are strongly preferred. Safety should be a “zero-cost abstraction.”\n    \n1.7 Rust’s big features\nOur tools shape what we believe we can create. Rust enables you to build the software that you want to make, but were too scared to try. What kind of tool is Rust? Flowing from the three principles discussed in the last section are three overarching features of the language:\n* Performance\n* Concurrency\n* Memory efficiency\n    \n1.7.1 Performance\nRust offers all of your computer’s available performance. Famously, Rust does not rely on a garbage collector to provide its memory safety.\n    \nThere is, unfortunately, a problem with promising you faster programs: the speed of your CPU is fixed. Thus, for software to run faster, it needs to do less. Yet, the lan- guage is large. To resolve this conflict, Rust pushes the burden onto the compiler.\n    \nThe Rust community prefers a bigger language with a compiler that does more, rather than a simpler language where the compiler does less. The Rust compiler aggressively optimizes both the size and speed of your program. Rust also has some less obvious tricks:\n* Cache-friendly data structures are provided by default. Arrays usually hold data within Rust programs rather than deeply nested tree structures that are created by pointers. This is referred to as data-oriented programming.\n* The availability of a modern package manager (cargo) makes it trivial to benefit from tens of thousands of open source packages. C and C++ have much less consistency here, and building large projects with many dependencies is typically difficult. \n* Methods are always dispatched statically unless you explicitly request dynamic dispatch. This enables the compiler to heavily optimize code, sometimes to the point of eliminating the cost of a function call entirely.\n\n1.7.2 Concurrency\nAsking a computer to do more than one thing at the same time has proven difficult for software engineers. As far as an OS is concerned, two independent threads of exe- cution are at liberty to destroy each other if a programmer makes a serious mistake. Yet Rust has spawned the expression fearless concurrency. Its emphasis on safety crosses the bounds of independent threads. There is no global interpreter lock (GIL) to con- strain a thread’s speed. We explore some of the implications of this in part 2.\n    \n1.7.3 Memory efficiency\nRust enables you to create programs that require minimal memory. When needed, you can use fixed-size structures and know exactly how every byte is managed. High- level constructs, such as iteration and generic types, incur minimal runtime overhead.\n\n1.8 Downsides of Rust\nIt’s easy to talk about this language as if it is the panacea for all software engineering. For example\n* “A high-level syntax with low-level performance!” \n* “Concurrency without crashes!”\n* “C with perfect safety!”\nThese slogans (sometimes overstated) are great. But for all of its merits, Rust does have some disadvantages.\n    \n1.8.1 Cyclic data structures\nIn Rust, it is difficult to model cyclic data like an arbitrary graph structure. Imple- menting a doubly-linked list is an undergraduate-level computer science problem. Yet Rust’s safety checks do hamper progress here. If you’re new to the language, avoid implementing these sorts of data structures until you’re more familiar with Rust.\n    \n1.8.2 Compile times\nRust is slower at compiling code than its peer languages. It has a complex compiler toolchain that receives multiple intermediate representations and sends lots of code to the LLVM compiler. The unit of compilation for a Rust program is not an individ- ual file but a whole package (known affectionately as a crate). As crates can include TLS security case studies 21 multiple modules, these can be exceedingly large units to compile. Although this enables whole-of-crate optimization, it requires whole-of-crate compilation as well.\n    \n1.8.3 Strictness\nIt’s impossible—well, difficult—to be lazy when programming with Rust. Programs won’t compile until everything is just right. The compiler is strict, but helpful.\n    \nOver time, it’s likely that you’ll come to appreciate this feature. If you’ve ever pro- grammed in a dynamic language, then you may have encountered the frustration of your program crashing because of a misnamed variable. Rust brings that frustration forward so that your users don’t have to experience the frustration of things crashing.\n    \n1.8.4 Size of the language\nRust is large! It has a rich type system, se several dozen keywords, and includes some fea- tures that are unavailable in other languages. These factors all combine to create a steep learning curve. To make this manageable, I encourage learning Rust gradually. Start with a minimal subset of the language and give yourself time to learn the details when you need these. That is the approach taken in this book. Advanced concepts are deferred until much later.\n    \n1.8.5 Hype\nThe Rust community is wary of growing too quickly and being consumed by hype. Yet, a number of software projects have encountered this question in their Inbox: “Have you considered rewriting this in Rust?” Unfortunately, software written in Rust is still software. It not immune to security problems and does not offer a panacea to all of software engineering’s ills.\n    \n1.9 TLS security case studies\nTo demonstrate that Rust will not alleviate all errors, let’s examine two serious exploits that threatened almost all internet-facing devices and consider whether Rust would have prevented those.\nBy 2015, as Rust gained prominence, implementations of SSL/TLS (namely, OpenSSL and Apple’s own fork) were found to have serious security holes. Known informally as Heartbleed and goto fail;, both exploits provide opportunities to test Rust’s claims of memory safety. Rust is likely to have helped in both cases, but it is still possi- ble to write Rust code that suffers from similar issues.\n    \n1.9.1 Heartbleed\nHeartbleed, officially designated as CVE-2014-0160,16 was caused by re-using a buffer incorrectly. A buffer is a space set aside in memory for receiving input. Data can leak from one read to the next if the buffer’s contents are not cleared between writes.\nWhy does this situation occur? Programmers hunt for performance. Buffers are reused to minimize how often memory applications ask for memory from the OS.\n    \nImagine that we want to process some secret information from multiple users. We decide, for whatever reason, to reuse a single buffer through the course of the pro- gram. If we don’t reset this buffer once we use it, information from earlier calls will leak to the latter ones. Here is a précis of a program that would encounter this error:\n```\nlet buffer = &mut[0u8; 1024];\n  read_secrets(&user1, buffer);\n  store_secrets(buffer);\n  read_secrets(&user2, buffer);\n  store_secrets(buffer);\n```\n    \nRust does not protect you from logical errors. It ensures that your data is never able to be written in two places at the same time. It does not ensure that your program is free from all security issues.\n\n    \n1.9.2 Go to fail;\nThe goto fail; bug, officially designated as CVE-2014-1266,17 was caused by program- mer error coupled with C design issues (and potentially by its compiler not pointing out the flaw). A function that was designed to verify a cryptographic key pair ended up skipping all checks. Here is a selected extract from the original SSLVerifySigned- ServerKeyExchange function with a fair amount of obfuscatory syntax retained:18\n```\n1 static OSStatus\n2 SSLVerifySignedServerKeyExchange (SSLContext *ctx,\n3      bool isRsa,\n4      SSLBuffer signedParams, \n5      uint8 t *signature,  \n6      UInt16 signatureLen)\n7{\n8 OSStatus err;\n9 ...\n10\n11 if ((err = SSLHashSHA1.update( \n12 &hashCtx, &serverRandom)) != 0)\n13 go to fail;\n14\n15 if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)\n```\n    \nIn the example code, the issue lies between lines 15 and 17. In C, logical tests do not require curly braces. C compilers interpret those three lines like this:\n```\nif ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0) {\ngoto fail; }\ngoto fail;\n```\nWould Rust have helped? Probably. In this specific case, Rust’s grammar would have caught the bug. It does not allow logical tests without curly braces. Rust also issues a warning when code is unreachable. But that doesn’t mean the error is made impossi- ble in Rust. Stressed programmers under tight deadlines make mistakes. In general, similar code would compile and run.\n\n1.10 Where does Rust fit best?\nAlthough it was designed as a systems programming language, Rust is a general-purpose language. It has been successfully deployed in many areas, which we discuss next.\n    \n1.10.1 Command-line utilities\nRust offers three main advantages for programmers creating command-line utilities: minimal startup time, low memory use, and easy deployment. Programs start their work quickly because Rust does not need to initialize an interpreter (Python, Ruby, etc.) or virtual machine (Java, C#, etc.).\n\nAs a bare metal language, Rust produces memory-efficient programs.19 As you’ll see throughout the book, many types are zero-sized. That is, these only exist as hints to the compiler and take up no memory at all in the running program.\n    \nUtilities written in Rust are compiled as static binaries by default. This compilation method avoids depending on shared libraries that you must install before the pro- gram can run. Creating programs that can run without installation steps makes these easy to distribute.\n    \n1.10.2 Data processing\nRust excels at text processing and other forms of data wrangling. Programmers bene- fit from control over memory use and fast startup times. As of mid-2017, Rust touts the world’s fastest regular expression engine. In 2019, the Apache Arrow data-processing project—foundational to the Python and R data science ecosystems—accepted the Rust-based DataFusion project.\n    \nRust also underlies the implementation of multiple search engines, data-processing engines, and log-parsing systems. Its type system and memory control provide you with the ability to create high throughput data pipelines with a low and stable memory footprint. Small filter programs can be easily embedded into the larger framework via Apache Storm, Apache Kafka, or Apache Hadoop streaming.\n    \n1.10.3 Extending applications\nRust is well suited for extending programs written in a dynamic language. This enables JNI (Java Native Interface) extensions, C extensions, or Erlang/Elixir NIFs (native implemented functions) in Rust. C extensions are typically a scary proposition. These tend to be quite tightly integrated with the runtime. Make a mistake and you could be looking at runaway memory consumption due to a memory leak or a com- plete crash. Rust takes away a lot of this anxiety.\n* Sentry, a company that processes application errors, finds that Rust is an excellent candidate for rewriting CPU-intensive components of their Python system.20\n* Dropbox used Rust to rewrite the file synchronization engine of its client-side application: “More than performance, [Rust’s] ergonomics and focus on cor- rectness have helped us tame sync’s complexity.”\n    \n1.10.4 Resource-constrained environments\nC has occupied the domain of microcontrollers for decades. Yet, the Internet of Things (IoT) is coming. That could mean many billions of insecure devices exposed to the network. Any input parsing code will be routinely probed for weaknesses. Given how infrequently firmware updates for these devices occur, it’s critical that these are as secure as possible from the outset. Rust can play an important role here by adding a layer of safety without imposing runtime costs.\n    \n1.10.5 Server-side applications\nMost applications written in Rust live on the server. These could be serving web traffic or supporting businesses running their operations. There is also a tier of services that sit between the OS and your application. Rust is used to write databases, monitoring systems, search appliances, and messaging systems. For example\n* The npm package registry for the JavaScript and node.js communities is written in Rust.22\n* sled (https://github.com/spacejam/sled), an embedded database, can process a workload of 1 billion operations that includes 5% writes in less than a minute on a 16-core machine.\n* Tantivy, a full text search engine, can index 8 GB of English Wikipedia in approximately 100 s on a 4-core desktop machine.23\n1.10.6 Desktop applications\nThere is nothing inherent in Rust’s design that prevents it from being deployed to develop user-facing software. Servo, the web browser engine that acted as an incuba- tor for Rust’s early development, is a user-facing application. Naturally, so are games.\n    \n1.10.7 Desktop\nThere is still a significant need to write applications that live on people’s computers. Desktop applications are often complex, difficult to engineer, and hard to support. With Rust’s ergonomic approach to deployment and its rigor, it is likely to become the secret sauce for many applications. To start, these will be built by small, independent developers. As Rust matures, so will the ecosystem.\n    \n1.10.8 Mobile\nAndroid, iOS, and other smartphone operating systems generally provide a blessed path for developers. In the case of Android, that path is Java. In the case of macOS, developers generally program in Swift. There is, however, another way.\nBoth platforms provide the ability for native applications to run on them. This is generally intended for applications written in C++, such as games, to be able to be deployed to people’s phones. Rust is able to talk to the phone via the same interface with no additional runtime cost.\n    \n1.10.9 Web\nAs you are probably aware, JavaScript is the language of the web. Over time though, this will change. Browser vendors are developing a standard called WebAssembly (Wasm) that promises to be a compiler target for many languages. Rust is one of the first. Porting a Rust project to the browser requires only two additional command-line commands. Several companies are exploring the use of Rust in the browser via Wasm, notably CloudFlare and Fastly.\n    \n1.10.10 Systems programming\nIn some sense, systems programming is Rust’s raison d’être. Many large programs have been implemented in Rust, including compilers (Rust itself), video game engines, and operating systems. The Rust community includes writers of parser generators, databases, and file formats.\n    \nRust has proven to be a productive environment for programmers who share Rust’s goals. Three standout projects in this area include the following:\n* Google is sponsoring the development of Fuchsia OS, an operating system for devices.24\n* Microsoft is actively exploring writing low-level components in Rust for Win- dows.25\n* Amazon Web Services (AWS) is building Bottlerocket, a bespoke OS for hosting containers in the cloud.26\n    \n1.11 Rust’s hidden feature: Its community\nIt takes more than software to grow a programming language. One of the things that the Rust team has done extraordinarily well is to foster a positive and welcoming com- munity around the language. Everywhere you go within the Rust world, you’ll find that you’ll be treated with courtesy and respect.\n    \n1.12 Rust phrase book\nWhen you interact with members of the Rust community, you’ll soon encounter a few terms that have special meaning. Understanding the following terms makes it easier to understand why Rust has evolved the way that it has and the problems that it attempts to solve:\n* Empowering everyone—All programmers regardless of ability or background are welcome to participate. Programming, and particularly systems programming, should not be restricted to a blessed few.\n Blazingly fast—Rust is a fast programming language. You’ll be able to write pro- grams that match or exceed the performance of its peer languages, but you will have more safety guarantees.\n* Fearless concurrency—Concurrent and parallel programming have always been seen as difficult. Rust frees you from whole classes of errors that have plagued its peer languages.\n* No Rust 2.0—Rust code written today will always compile with a future Rust compiler. Rust is intended to be a reliable programming language that can be depended upon for decades to come. In accordance with semantic versioning, Rust is never backward-incompatible, so it will never release a new major ver- sion.\n* Zero-cost abstractions—The features you gain from Rust impose no runtime cost. When you program in Rust, safety does not sacrifice speed.", "Rust language is well loved by software developers. It has repeatedly won Stack Overflow’s “most loved programming language” title."